#! /usr/bin/python
import sys
from optparse import OptionParser
import datetime

running_task_list = []
ready_task_list = []
waiting_task_list = []
finish_event_list = []
task_length_dict = {}

subtree_max_parallel = {}

origin_task_list = []
origin_task_children_list_dict = {} #each item in it is a <task_id, children_list>
origin_task_dependency_list_dict = {} #each item in it is a <task_id, dependency_list>

#each task should contains the task id, task length, task dependency
#keep tracking waiting_task_list, once the task is ready (all its dependency is ready), put it into ready_task_list; 

def initialize_struct_full(filename):
	real_cost = 0 
	with open(filename) as task_file:
		task_children_list_dict = {} #each item in it is a <task_id, children_list>
		task_dependency_list_dict = {} #each item in it is a <task_id, dependency_list>

		for line in task_file:
			first_space = line.find(' ', 0)
			task_id = line[:first_space]
			second_space = line.find(' ', first_space + 1)
			task_length = line[first_space + 1:second_space]
			real_cost += int(task_length)
			task_length_dict[task_id] = task_length
			right_brace = line.find(']', second_space + 1)
			task_dependency = line[second_space + 2:right_brace]
			task_dependency = task_dependency.replace(' ', '')
			task_dependency_list = task_dependency.split(',')
			if task_dependency_list == ['']:
				task_dependency_list = []
			task_dependency_list_dict[task_id] = task_dependency_list
			for dependency in task_dependency_list:
				if dependency in task_children_list_dict:
					task_children_list_dict[dependency].append( task_id)
				else: 
					task_children_list_dict[dependency] = [task_id]
			waiting_task_list.append(task_id)
	return real_cost, task_children_list_dict, task_dependency_list_dict
	
def initialize_struct_half(filename):
	task_list = []
	with open(filename) as task_file:
		task_children_list_dict = {} #each item in it is a <task_id, children_list>
		task_dependency_list_dict = {} #each item in it is a <task_id, dependency_list>
		for line in task_file:
			first_space = line.find(' ', 0)
			task_id = int(line[:first_space])
			task_list.append(task_id)
			right_brace = line.find(']', first_space + 1)
			task_dependency = line[first_space + 2:right_brace]
			task_dependency = task_dependency.replace(' ', '')
			task_dependency_list = task_dependency.split(',')
			if task_dependency_list == ['']:
				task_dependency_list = []
			else:
				temp_list = []
				for item in task_dependency_list:
					temp_list.append(int(item))
				task_dependency_list = temp_list[:]
			task_dependency_list_dict[task_id] = task_dependency_list
			for dependency in task_dependency_list:
				if int(dependency) in task_children_list_dict:
					task_children_list_dict[int(dependency)].append(task_id)
				else: 
					task_children_list_dict[int(dependency)] = [task_id]
	#task_dependency_list_dict and task_children_list_dict uniquely define a workflow
	return task_dependency_list_dict, task_children_list_dict, task_list

def insert_finish_event_list(task_id, finish_time):
	global finish_event_list
	if len(finish_event_list) == 0:
		finish_event_list = [{str(finish_time):task_id}]
	else:
		pos = 0
		while len(finish_event_list) > pos  and finish_time >= int((finish_event_list[pos]).keys()[0]):
			pos = pos + 1
		finish_event_list.insert(pos, {str(finish_time):task_id})

#check each task in waiting_task_list, to see whether its ready to be put into ready_task_list
#then check each task in the ready_task_list, check whether there are idle machines to run it
#then jump the time to the first item in finish_event_list
def schedule_tasks(task_children_list_dict, task_dependency_list_dict):
	running_machines = 0
	current_time = 0
	max_used_machines = 0
	time_interval_endpoint_list = [0] 
	time_interval_width_list = [] #the number of running tasks during the last time interval
	while waiting_task_list:
		iterator = 0
		waiting_to_ready_tasks = []
		while iterator < len(waiting_task_list):
			task_id = waiting_task_list[iterator]
			if not task_dependency_list_dict[task_id]:
				ready_task_list.append(task_id)
			iterator = iterator + 1
	
		for item in ready_task_list:
			if item in waiting_task_list:
				waiting_task_list.remove(item)	
	
		print "\nAt time %d:" % current_time
		while len(ready_task_list) > 0:
			first_ready_task = ready_task_list.pop(0)
			print "Start to run task %s, the task length is %s." % (first_ready_task, task_length_dict[first_ready_task])
			first_ready_task_length = task_length_dict[first_ready_task]
			insert_finish_event_list(first_ready_task, current_time + int(task_length_dict[first_ready_task]))
			running_task_list.append(first_ready_task)
			running_machines += 1
			if running_machines > max_used_machines:
				max_used_machines = running_machines
	
		print "task_children_list_dict", task_children_list_dict
		print "task_length_dict", task_length_dict
		print "task_dependency_list_dict", task_dependency_list_dict
		print "running_task_list", running_task_list
		print "ready_task_list", ready_task_list
		print "waiting_task_list", waiting_task_list
		print "finish_event_list", finish_event_list
	
		#jump the time to the first item in finish_event_list
		last_len_running_task_list = len(running_task_list)
		if len(finish_event_list) > 0: 
			current_time = int((finish_event_list[0]).keys()[0])
			next_finish_event_time = current_time
			while len(finish_event_list) > 0 and next_finish_event_time == current_time:
				first_finish_event = finish_event_list[0]
				finish_task_id = first_finish_event[str(current_time)]
				print "Finish task %s at time %d" % (finish_task_id, current_time)
				running_task_list.remove(finish_task_id)
				running_machines -= 1
				finish_event_list.pop(0)
				if finish_task_id in task_children_list_dict:
					for item in task_children_list_dict[finish_task_id]:
						task_dependency_list_dict[item].remove(finish_task_id)	
					if len(finish_event_list) > 0:
						next_finish_event_time = int((finish_event_list[0]).keys()[0])
					else:
						break
		time_interval_endpoint_list.append(current_time)
		time_interval_width_list.append(last_len_running_task_list)
	return (current_time, max_used_machines, time_interval_endpoint_list, time_interval_width_list)

def full_process(filename):
	real_cost, task_children_list_dict, task_dependency_list_dict = initialize_struct_full(filename)
	(execution_time, max_used_machines, time_interval_endpoint_list, time_interval_width_list) = schedule_tasks(task_children_list_dict, task_dependency_list_dict)
	total_cost = max_used_machines * int(execution_time)
	idle_cost = total_cost - real_cost
	wastage = float(idle_cost) / total_cost

	print "\nReal cost (sum of task lengths): %d" % (real_cost)
	print "Max used machines: %d" % max_used_machines 
	print "Execution time: %s" % execution_time
	print "Total cost (machine number * execution time): %d" % (total_cost)
	print "Idle cost (total cost - real cost): %d" % idle_cost
	print "Wastage (idle cost / total cost): %5.4f" % wastage
		
	time_interval_contribute_list = []
	for i in range(0, len(time_interval_width_list)):
		contribute = time_interval_width_list[i] * (time_interval_endpoint_list[i+1] - time_interval_endpoint_list[i])
		time_interval_contribute_list.append(contribute)
	print "time_interval_endpoint_list", time_interval_endpoint_list
	print "time_interval_width_list", time_interval_width_list
	print "time_interval_contribute_list", time_interval_contribute_list

	optimized_machine_number = 0
	for i in range(0, len(time_interval_width_list)):
		optimized_machine_number += time_interval_width_list[i] * (time_interval_contribute_list[i] / float(real_cost))
	print "Optimized Machine Number: ", optimized_machine_number
	

def initialize_ancestor_list(task_dependency_list_dict):
	task_ancestors_list_dict = {}
	for key in sorted(task_dependency_list_dict.keys()):
		task_ancestors_list_dict[key] = []
		if len(task_dependency_list_dict[key]) == 0:
			task_ancestors_list_dict[key] = []
		else:
			for item in task_dependency_list_dict[key]:
				task_ancestors_list_dict[key] += task_ancestors_list_dict[item]
				task_ancestors_list_dict[key].append(item)
			task_ancestors_list_dict[key] = list(set(task_ancestors_list_dict[key]))
	return task_ancestors_list_dict

def initialize_descendants_list(task_children_list_dict):
	task_descendants_list_dict = {}
	for key in sorted(task_children_list_dict.keys(), reverse=True):
		task_descendants_list_dict[key] = []
		if len(task_children_list_dict[key]) == 0:
			task_descendants_list_dict[key] = []
		else:
			for item in task_children_list_dict[key]:
				if item not in task_children_list_dict:
					task_descendants_list_dict[item] = []
				task_descendants_list_dict[key] += task_descendants_list_dict[item]
				task_descendants_list_dict[key].append(item)
			task_descendants_list_dict[key] = list(set(task_descendants_list_dict[key]))
	return task_descendants_list_dict

def intialize_direct_relatives_list(task_ancestors_list_dict, task_descendants_list_dict):
	task_direct_relatives_list_dict = {}
	for key in task_ancestors_list_dict:
		if key not in task_descendants_list_dict:
			task_descendants_list_dict[key] = []
		task_direct_relatives_list_dict[key] = list(set(task_ancestors_list_dict[key]) | set(task_descendants_list_dict[key]))
	return task_direct_relatives_list_dict

''' Calculate the maximal parallel degree of each task in a workflow
'''
def max_degree(task_dependency_list_dict, task_children_list_dict, task_list, filename):
	global subtree_max_parallel
	task_list_str = ''
	for key in sorted(task_list):
		task_list_str += str(key)
	if key in subtree_max_parallel:
		return subtree_max_parallel[task_list_str]
#	print "max_degree **********"
#	print "task_list: ", task_list 
#	print "task_children_list_dict: ", task_children_list_dict 
#	print "task_dependency_list_dict: ", task_dependency_list_dict 
#	for key, value in task_dependency_list_dict.items():
#		print key, value
#	for key, value in task_children_list_dict.items():
#		print key, value
	#calculate the ancestor list of each task, the descendant list of each task
	task_ancestors_list_dict = initialize_ancestor_list(task_dependency_list_dict)
	task_descendants_list_dict = initialize_descendants_list(task_children_list_dict)
	task_direct_relatives_list_dict = intialize_direct_relatives_list(task_ancestors_list_dict, task_descendants_list_dict)
#	print "task_ancestors_list_dict: ", task_ancestors_list_dict
#	print "task_descendants_list_dict: ", task_descendants_list_dict
#	print "task_direct_relatives_list_dict", task_direct_relatives_list_dict
	max_parallel_tasks_dict = {}
	max_parallel_value = 0
	for item in task_list:
		max_parallel_tasks_dict[item] = 0
		temp_list = task_list[:]
		indirect_relatives_list = list(set(temp_list) - set(task_direct_relatives_list_dict[item]))
#		print "item, indirect_relatives_list: ", item, indirect_relatives_list
		conflict_tasks_no = 0
		for item1 in sorted(indirect_relatives_list):
			temp_list1 = indirect_relatives_list[:]
			union_list = list(set(temp_list1) & set(task_direct_relatives_list_dict[item1]))
			if len(union_list) > 0:
#				print item1, "has some direct relative whose belongs to the indirect_relatives_list of,", item
				conflict_tasks_no += 1
				#construct new task_dependency_list_dict, task_children_list_dict, task_list and recursively call max_degree
				temp_indirect_relatives_list = indirect_relatives_list[:]
				if item in temp_indirect_relatives_list:
					temp_indirect_relatives_list.remove(item)
				new_task_list = temp_indirect_relatives_list[:]
				new_task_dependency_list_dict, new_task_children_list_dict, origin_task_list = initialize_struct_half(filename)
				removed_task_list = list(set(origin_task_list) - set(new_task_list))
#				new_task_children_list_dict = dict(origin_task_children_list_dict)
#				new_task_dependency_list_dict = dict(origin_task_dependency_list_dict)
#				print "---task_list: ", task_list
#				print "new_task_list: ", new_task_list
#				print "new_task_list: ", new_task_list
#				print "removed_task_list: ", removed_task_list
#				print "origin_task_dependency_list_dict: ", origin_task_dependency_list_dict
#				print "origin_task_children_list_dict: ", origin_task_children_list_dict
				for key in removed_task_list:
					if key in new_task_children_list_dict:
						del new_task_children_list_dict[key]
					if key in new_task_dependency_list_dict:
						del new_task_dependency_list_dict[key]
#				print "remove all the removed nodes from new_task_children_list_dict and new_task_dependency_list_dict"
#				print "origin_task_dependency_list_dict: ", origin_task_dependency_list_dict
#				print "origin_task_children_list_dict: ", origin_task_children_list_dict
				for key2 in new_task_children_list_dict:
					for item2 in new_task_children_list_dict[key2]:
						if item2 in removed_task_list:
							new_task_children_list_dict[key2].remove(item2)

#				print "remove all the removed nodes from new_task_children_list_dict[key].remove(item2)"
#				print "origin_task_dependency_list_dict: ", origin_task_dependency_list_dict
#				print "origin_task_children_list_dict: ", origin_task_children_list_dict
			
				for key3 in new_task_dependency_list_dict:
					for item3 in new_task_dependency_list_dict[key3]:
						if item3 in removed_task_list:
							new_task_dependency_list_dict[key3].remove(item3)
				
#				print "remove all the removed nodes from new_task_dependency_list_dict[key].remove(item3)"
#				print "origin_task_dependency_list_dict: ", origin_task_dependency_list_dict
#				print "origin_task_children_list_dict: ", origin_task_children_list_dict
#
#				print "new_task_children_list_dict: ", new_task_children_list_dict
#				print "new_task_dependency_list_dict: ", new_task_dependency_list_dict
#				print "origin_task_dependency_list_dict: ", origin_task_dependency_list_dict
#				print "origin_task_children_list_dict: ", origin_task_children_list_dict
				max_temp = 1 + max_degree(new_task_dependency_list_dict, new_task_children_list_dict, new_task_list, filename)
#				print "max_temp, item: ", max_temp, item
				if max_temp > max_parallel_tasks_dict[item]:
					max_parallel_tasks_dict[item] = max_temp
		if conflict_tasks_no == 0:
			max_parallel_tasks_dict[item] = len(indirect_relatives_list)
#		print "item, max_parallel_tasks_dict[item]: ", item, max_parallel_tasks_dict[item]
		if max_parallel_tasks_dict[item] > max_parallel_value:
			max_parallel_value = max_parallel_tasks_dict[item]
	print "max_parallel_value: ", max_parallel_value, "for task_list: ", task_list, "***************"
	task_list_str = ''
	for key in sorted(task_list):
		task_list_str += str(key)
	subtree_max_parallel[task_list_str] = max_parallel_value
	return max_parallel_value	

def level_width(task_dependency_list_dict):
	level_dict = {}
	level = 1
	task_num = len(task_dependency_list_dict)
	access_flag_list = [0] * task_num
	print access_flag_list
	while task_num > 0:
		level_dict[level] = [] 
		for key in task_dependency_list_dict:
			if len(task_dependency_list_dict[key]) == 0 and access_flag_list[key - 1] == 0:
				print "deal with ", key
				level_dict[level].append(key)
				access_flag_list[key - 1] = 1
				task_num -= 1
				print "level_dict: ", level_dict
				print "task_num: ", task_num

		for key in level_dict[level]:
			for key1 in task_dependency_list_dict:
				if key in task_dependency_list_dict[key1]:
					task_dependency_list_dict[key1].remove(key)
		level += 1
	print level_dict
	return level_dict

def half_process(filename):
	print "Starting: ", datetime.datetime.now()
	task_dependency_list_dict, task_children_list_dict, task_list = initialize_struct_half(filename)
	print task_dependency_list_dict, task_children_list_dict, task_list
	level_width_dict = level_width(task_dependency_list_dict)
#	global origin_task_dependency_list_dict
#	origin_task_dependency_list_dict = dict(task_dependency_list_dict)
#	global origin_task_children_list_dict
#	origin_task_children_list_dict = dict(task_children_list_dict)
#	global origin_task_list
#	origin_task_list = task_list[:]
#	max_degree(task_dependency_list_dict, task_children_list_dict, task_list, filename)
#	print "Ending: ", datetime.datetime.now()
#	pass

def zero_process(filename):
	pass

def main():
	#Problem: extension support incremental download
	parser = OptionParser(usage="usage: %prog --degree full|half|zero taskfile",
						version="%prog 1.0")
	parser.add_option("-d", "--degree",
					action="store",
					help="The user's knowledge about each task length, which can be full, half, zero.\nFull: The length of each task is known.\nHalf: The task length is unknown, but the tasks on the same levels takes similar time.\nZero: The task length is unknown, and the tasks on the same level may take different times.")
	(options, args) = parser.parse_args()

	task_info = options.degree
	filename = sys.argv[-1]

	if task_info == 'full':	
		full_process(filename)
	elif task_info == 'half':
		half_process(filename)
		pass
	elif task_info == 'zero':
		pass
	else:
		sys.exit("Unknown degree option. The degree option can be full, half, or zero.")

if __name__ == "__main__":
	main()





